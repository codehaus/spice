    $Id: Attributes.txt,v 1.3 2002-11-27 11:12:00 donaldp Exp $

                 Metadata for Avalon Framework

There has been a demonstrated need to add metadata about various artefacts
in Avalon for a long time. Sometimes we have intermingled the meta-data with
code (ie ECMs marker interfaces), sometimes we have stored it along with 
assembly data (ie Fortresses roles.xml or early Phoenix) and sometimes we have 
separated it out into external files (ie BlockInfo). The metadata could only be 
associated with fixed set of elements. Historically we have also had strongly 
typed meta-data with very fixed schemas.

More recent history have given us richer metadata models and allowed us to 
attach metadata to many more artefacts; such as libraries via the Extension 
API or even down to method/field level for management info. There has also 
been experiments wrt more generic forms of metadata.

The findings of all this work would basically be that;
 * we need an extensible mechanism for defining metadata
 * the metadata attached to different artefacts should probably share the
   same representation.
 * we need to have a large variety of artefacts to attach metadata to. 
   Examples;
    - Jar File
    - Java Package
    - Class
    - Method
    - Method Parameter
    - Field
    - Component
    - Service

The physical form of the metadata is not that important - whether the metadata
is extracted from xml, binary or some type of runtime attribute metadata is 
irrelevent. Different containers are likely to have different requirements (ie
J2ME will likely use binary metadata for speed/memory advantages but something 
like Phoenix will probably continue to use XML descriptors). Most of the
containers will have the ability to load metadata from any supported source
though some may choose to not support some formats due to the cost of 
implementing support (ie J2ME may not need the overhead of an XML parser so may 
do away with XML source support).

There must also be mechanisms in place to support inheritance or non-inheritance
of metadata. Some metadata is inheritable and some isn't. The inheritability is a
characteristeric of the metadata and must be treated as such. Optionally we may 
support blending of metadata based on primary key of different elements (see 
XDoclet for further examples) however this may not necessarily be worth the effort.

Metadata must also be able to be validated against som sort schema. However as the 
metadata is extensible it must take into account that unknown elements may not be 
validated but all known elements hsould be able to be validated.

As the metadata must be extensible, there must be a way to classify whether features
described by metadata elements must be understood or are only optionally understood.
For example a persistent object that has persistence related metadata must be hosted
in a container that supports persistence. However a component that has metadata 
suggesting security constraints can still run if the container does not understand
(or comply with) the security metadata.

